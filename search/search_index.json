{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notes DFT","title":"Notes"},{"location":"#notes","text":"DFT","title":"Notes"},{"location":"math/dft_matrix/","text":"DFT matrix DFT matrix is a square Vandermonde matrix , where the numbers \\(x_i\\) are chosen to be roots of unity. For example let \\(n = 8\\) and \\(\\omega = e^{\\frac{-2\\pi i}{8} }= \\frac{1}{\\sqrt{2}} - \\frac{i}{\\sqrt{2}}\\) (primitive 8 th root of unity). We choose the points \\(x_0, \\ldots, x_7\\) to be 8 th roots of unity: \\[\\begin{aligned} x_0& = \\omega ^0 = &1 \\\\ x_1 &= \\omega ^1 = &\\omega\\\\ x_2 &= \\omega ^2 = &-i\\\\ x_3 &= \\omega ^3 = &-i \\omega\\\\ x_4 &= \\omega ^4 = &-1\\\\ x_5 &= \\omega ^5 = &-\\omega\\\\ x_6 &= \\omega ^6 = &i \\\\ x_7 &= \\omega ^7 = &i \\omega \\end{aligned}\\] Then the DFT matrix is (note \\(\\omega^8 = 1\\) ): \\[{\\displaystyle V={\\begin{bmatrix} 1&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}\\\\ 1&\\omega ^{1}&\\omega ^{2}&\\omega ^{3}&\\omega ^{4}&\\omega ^{5}&\\omega ^{6}&\\omega ^{7}\\\\ 1&\\omega ^{2}&\\omega ^{4}&\\omega ^{6}&\\omega ^{8}&\\omega ^{10}&\\omega ^{12}&\\omega ^{14}\\\\ 1&\\omega ^{3}&\\omega ^{6}&\\omega ^{9}&\\omega ^{12}&\\omega ^{15}&\\omega ^{18}&\\omega ^{21}\\\\ 1&\\omega ^{4}&\\omega ^{8}&\\omega ^{12}&\\omega ^{16}&\\omega ^{20}&\\omega ^{24}&\\omega ^{28}\\\\ 1&\\omega ^{5}&\\omega ^{10}&\\omega ^{15}&\\omega ^{20}&\\omega ^{25}&\\omega ^{30}&\\omega ^{35}\\\\ 1&\\omega ^{6}&\\omega ^{12}&\\omega ^{18}&\\omega ^{24}&\\omega ^{30}&\\omega ^{36}&\\omega ^{42}\\\\ 1&\\omega ^{7}&\\omega ^{14}&\\omega ^{21}&\\omega ^{28}&\\omega ^{35}&\\omega ^{42}&\\omega ^{49}\\\\ \\end{bmatrix}}={\\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ \\end{bmatrix}}}\\] To convert back use the inverse: \\[{\\displaystyle V^{-1} = \\frac{\\overline V}{n}={ \\frac{1}{n} \\cdot \\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ \\end{bmatrix}}}\\] Orthogonality of DFT matrix All the columns in \\(V\\) are orthogonal and since it's a change-of-base matrix it means the basis is orthogonal. The dot product of two complex vectors is defined as \\(\\textbf{a} \\cdot \\textbf{b} = \\sum a_j \\overline b_j\\) , where \\(\\overline b_j\\) is the complex conjugate of \\(b_j\\) . Proof: Let \\(\\textbf{a}, \\textbf{b}\\) be two different columns of the DFT matrix and \\(m, l\\; (m\\neq l)\\) the column numbers of \\(\\textbf{a}\\) and \\(\\textbf{b}\\) . \\[\\begin{aligned} \\textbf{a} \\cdot \\textbf{b} &= \\sum_{j=0}^{n-1} a_j \\overline b_j &\\text{definition of complex dot product}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{jm} \\omega^{-jl} &\\text{definition of $\\omega$ in DFT}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{(m-l)j} &\\text{exponential multiplication rules}\\\\ &= \\sum_{j=0}^{n-1} \\omega_{k}^{j} &\\omega^{m-l} \\text{ is a fixed root of unity, call it }\\omega_{k}\\\\ &= \\frac{1 - \\omega_{k}^{n}}{1 - \\omega_{k}} &\\text{geometric series formula, note } \\omega_k \\neq 1\\\\ &= \\frac{1 - 1}{1 - \\omega_k} &{\\omega^n = \\omega^0 = 1}\\\\ &= 0\\end{aligned}\\] QED Links: wikipedia","title":"DFT Matrix"},{"location":"math/dft_matrix/#dft-matrix","text":"DFT matrix is a square Vandermonde matrix , where the numbers \\(x_i\\) are chosen to be roots of unity. For example let \\(n = 8\\) and \\(\\omega = e^{\\frac{-2\\pi i}{8} }= \\frac{1}{\\sqrt{2}} - \\frac{i}{\\sqrt{2}}\\) (primitive 8 th root of unity). We choose the points \\(x_0, \\ldots, x_7\\) to be 8 th roots of unity: \\[\\begin{aligned} x_0& = \\omega ^0 = &1 \\\\ x_1 &= \\omega ^1 = &\\omega\\\\ x_2 &= \\omega ^2 = &-i\\\\ x_3 &= \\omega ^3 = &-i \\omega\\\\ x_4 &= \\omega ^4 = &-1\\\\ x_5 &= \\omega ^5 = &-\\omega\\\\ x_6 &= \\omega ^6 = &i \\\\ x_7 &= \\omega ^7 = &i \\omega \\end{aligned}\\] Then the DFT matrix is (note \\(\\omega^8 = 1\\) ): \\[{\\displaystyle V={\\begin{bmatrix} 1&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}\\\\ 1&\\omega ^{1}&\\omega ^{2}&\\omega ^{3}&\\omega ^{4}&\\omega ^{5}&\\omega ^{6}&\\omega ^{7}\\\\ 1&\\omega ^{2}&\\omega ^{4}&\\omega ^{6}&\\omega ^{8}&\\omega ^{10}&\\omega ^{12}&\\omega ^{14}\\\\ 1&\\omega ^{3}&\\omega ^{6}&\\omega ^{9}&\\omega ^{12}&\\omega ^{15}&\\omega ^{18}&\\omega ^{21}\\\\ 1&\\omega ^{4}&\\omega ^{8}&\\omega ^{12}&\\omega ^{16}&\\omega ^{20}&\\omega ^{24}&\\omega ^{28}\\\\ 1&\\omega ^{5}&\\omega ^{10}&\\omega ^{15}&\\omega ^{20}&\\omega ^{25}&\\omega ^{30}&\\omega ^{35}\\\\ 1&\\omega ^{6}&\\omega ^{12}&\\omega ^{18}&\\omega ^{24}&\\omega ^{30}&\\omega ^{36}&\\omega ^{42}\\\\ 1&\\omega ^{7}&\\omega ^{14}&\\omega ^{21}&\\omega ^{28}&\\omega ^{35}&\\omega ^{42}&\\omega ^{49}\\\\ \\end{bmatrix}}={\\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ \\end{bmatrix}}}\\] To convert back use the inverse: \\[{\\displaystyle V^{-1} = \\frac{\\overline V}{n}={ \\frac{1}{n} \\cdot \\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ \\end{bmatrix}}}\\]","title":"DFT matrix"},{"location":"math/dft_matrix/#orthogonality-of-dft-matrix","text":"All the columns in \\(V\\) are orthogonal and since it's a change-of-base matrix it means the basis is orthogonal. The dot product of two complex vectors is defined as \\(\\textbf{a} \\cdot \\textbf{b} = \\sum a_j \\overline b_j\\) , where \\(\\overline b_j\\) is the complex conjugate of \\(b_j\\) . Proof: Let \\(\\textbf{a}, \\textbf{b}\\) be two different columns of the DFT matrix and \\(m, l\\; (m\\neq l)\\) the column numbers of \\(\\textbf{a}\\) and \\(\\textbf{b}\\) . \\[\\begin{aligned} \\textbf{a} \\cdot \\textbf{b} &= \\sum_{j=0}^{n-1} a_j \\overline b_j &\\text{definition of complex dot product}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{jm} \\omega^{-jl} &\\text{definition of $\\omega$ in DFT}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{(m-l)j} &\\text{exponential multiplication rules}\\\\ &= \\sum_{j=0}^{n-1} \\omega_{k}^{j} &\\omega^{m-l} \\text{ is a fixed root of unity, call it }\\omega_{k}\\\\ &= \\frac{1 - \\omega_{k}^{n}}{1 - \\omega_{k}} &\\text{geometric series formula, note } \\omega_k \\neq 1\\\\ &= \\frac{1 - 1}{1 - \\omega_k} &{\\omega^n = \\omega^0 = 1}\\\\ &= 0\\end{aligned}\\] QED Links: wikipedia","title":"Orthogonality of DFT matrix"},{"location":"math/discrete_fft/","text":"Discrete Fast Fourier Transform FFT is fast way to calculate the DFT matrix multiplication. It exploits symmetries of roots of unity and thus we get the time complexity from O(n^2) down to O(n log n). Key Idea: Split polynomial into even and odd terms \\(A(x) = A_e(x) + A_o(x)\\) Even terms form an even function: \\(A_e(x) = A_e(-x)\\) Odd terms form an odd function: \\(A_o(x) = -A_o(-x)\\) Recursively compute \\(A_e(y) \\text{ and } A_o(y) \\text{ for } y \\in X^2 = \\{x^2 | x \\in X\\}\\) Combine \\(A(x) = A_e(x^2) + x \\cdot A_o(x^2)\\) I like to think about the DFT as a set of dot products between the signal and each base function (so conceptually it is in no way different than any other linear coordinate transform). And the FFT is a way to avoid explicitly computing every single dot product. Python implementation from math import e , pi from typing import List import numpy as np def fft ( p : List [ complex ]): # radix 2 Cooley-Tukey algorithm n = len ( p ) if not n and ( not ( n & ( n - 1 ))): # check if n is power of 2 raise ValueError ( \"This implementation requires arrays with length power of two\" ) if n == 1 : return p y_even , y_odd = fft ( p [:: 2 ]), fft ( p [ 1 :: 2 ]) omega = e ** ( - 2 j * pi / n ) # primitive nth root of unity y = [ 0 ] * n for i in range ( n // 2 ): y [ i ] = y_even [ i ] + omega ** i * y_odd [ i ] y [ i + n // 2 ] = y_even [ i ] - omega ** i * y_odd [ i ] return y def ifft ( p : List [ complex ]): # Take complex conjugates p = [ np . conj ( x ) for x in p ] # Calculate normal fft p = fft ( p ) # Take complex conjugates again and scale by 1/n n = len ( p ) return [ 1 / n * np . conj ( x ) for x in p ] Links Even and odd functions - wikipedia The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? - youtube","title":"Discrete FFT"},{"location":"math/discrete_fft/#discrete-fast-fourier-transform","text":"FFT is fast way to calculate the DFT matrix multiplication. It exploits symmetries of roots of unity and thus we get the time complexity from O(n^2) down to O(n log n). Key Idea: Split polynomial into even and odd terms \\(A(x) = A_e(x) + A_o(x)\\) Even terms form an even function: \\(A_e(x) = A_e(-x)\\) Odd terms form an odd function: \\(A_o(x) = -A_o(-x)\\) Recursively compute \\(A_e(y) \\text{ and } A_o(y) \\text{ for } y \\in X^2 = \\{x^2 | x \\in X\\}\\) Combine \\(A(x) = A_e(x^2) + x \\cdot A_o(x^2)\\) I like to think about the DFT as a set of dot products between the signal and each base function (so conceptually it is in no way different than any other linear coordinate transform). And the FFT is a way to avoid explicitly computing every single dot product.","title":"Discrete Fast Fourier Transform"},{"location":"math/discrete_fft/#python-implementation","text":"from math import e , pi from typing import List import numpy as np def fft ( p : List [ complex ]): # radix 2 Cooley-Tukey algorithm n = len ( p ) if not n and ( not ( n & ( n - 1 ))): # check if n is power of 2 raise ValueError ( \"This implementation requires arrays with length power of two\" ) if n == 1 : return p y_even , y_odd = fft ( p [:: 2 ]), fft ( p [ 1 :: 2 ]) omega = e ** ( - 2 j * pi / n ) # primitive nth root of unity y = [ 0 ] * n for i in range ( n // 2 ): y [ i ] = y_even [ i ] + omega ** i * y_odd [ i ] y [ i + n // 2 ] = y_even [ i ] - omega ** i * y_odd [ i ] return y def ifft ( p : List [ complex ]): # Take complex conjugates p = [ np . conj ( x ) for x in p ] # Calculate normal fft p = fft ( p ) # Take complex conjugates again and scale by 1/n n = len ( p ) return [ 1 / n * np . conj ( x ) for x in p ]","title":"Python implementation"},{"location":"math/discrete_fft/#links","text":"Even and odd functions - wikipedia The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? - youtube","title":"Links"},{"location":"math/discrete_fourier_transform/","text":"Discrete Fourier Transform Let's consider polynomial: \\(A(x) = a_0 \\cdot x^0 + a_1 \\cdot x^1 + a_2 \\cdot x^2 + ... + a_{n-1} \\cdot x^{n-1}\\) There are 3 different representations for this polynomial: Coefficient vector: \\(a_0 \\cdot x^0 + a_1 \\cdot x^1 + ... + a_{n-1} \\cdot x^{n-1}\\) Roots: \\(r_0, r_1, ..., r_{n-1}\\) such that \\(A = c \\cdot (x-r_0) \\cdot (x - r_1) \\cdots (x - r_{n-1})\\) Samples of the polynomial: \\((x_k, y_k)\\) for \\(\\; k=0, 1, ...n-1\\) where \\(A(x_k) = y_k \\; \\forall k\\) and \\(x_k\\) 's are distinct We can perform 3 different operation on the polynomials: Evaluate one polynomial Add two polynomials Multiply two polynomials The table for complexity for these operations based on the representation Operation Coefficients Roots Samples Evaluate O(n) O(n) O(n^2) Add O(n) \\(\\infty\\) O(n) Multiply O(n^2) O(n) O(n) Discrete fourier transform is the transform between coefficient and sample representations. Using FFT (fast fourier transform) algorithm we can perform this operation in O(n log n) time. The inverse operation also has same time complexity. The idea is that instead of performing O(n^2) operation, we will use FFT to transform the representation, then do the operation in O(n) time, then transform back with IFFT. This way we can perform all 3 operations in O(n log n) time or less. We can calculate the DFT with DFT Matrix or more efficiently with using FFT Links Divide & Conquer: FFT MIT OpenCourseWare DSP Lecture 10: The Discrete Fourier Transform","title":"Discrete FT"},{"location":"math/discrete_fourier_transform/#discrete-fourier-transform","text":"Let's consider polynomial: \\(A(x) = a_0 \\cdot x^0 + a_1 \\cdot x^1 + a_2 \\cdot x^2 + ... + a_{n-1} \\cdot x^{n-1}\\) There are 3 different representations for this polynomial: Coefficient vector: \\(a_0 \\cdot x^0 + a_1 \\cdot x^1 + ... + a_{n-1} \\cdot x^{n-1}\\) Roots: \\(r_0, r_1, ..., r_{n-1}\\) such that \\(A = c \\cdot (x-r_0) \\cdot (x - r_1) \\cdots (x - r_{n-1})\\) Samples of the polynomial: \\((x_k, y_k)\\) for \\(\\; k=0, 1, ...n-1\\) where \\(A(x_k) = y_k \\; \\forall k\\) and \\(x_k\\) 's are distinct We can perform 3 different operation on the polynomials: Evaluate one polynomial Add two polynomials Multiply two polynomials The table for complexity for these operations based on the representation Operation Coefficients Roots Samples Evaluate O(n) O(n) O(n^2) Add O(n) \\(\\infty\\) O(n) Multiply O(n^2) O(n) O(n) Discrete fourier transform is the transform between coefficient and sample representations. Using FFT (fast fourier transform) algorithm we can perform this operation in O(n log n) time. The inverse operation also has same time complexity. The idea is that instead of performing O(n^2) operation, we will use FFT to transform the representation, then do the operation in O(n) time, then transform back with IFFT. This way we can perform all 3 operations in O(n log n) time or less. We can calculate the DFT with DFT Matrix or more efficiently with using FFT","title":"Discrete Fourier Transform"},{"location":"math/discrete_fourier_transform/#links","text":"Divide & Conquer: FFT MIT OpenCourseWare DSP Lecture 10: The Discrete Fourier Transform","title":"Links"},{"location":"math/monoid/","text":"Abstract algebra monoid Magma Magma is a set equipped with a binary operation that is closed: \\[ a,b \\in S \\implies a \\cdot b \\in S. \\] Semigroup Magma that is associative : $$ \\forall a, b. c \\in S \\implies (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c) $$ is called a semigroup. Monoid Semigroup with identity \\(e\\) : $$ \\exists e \\in S \\text{ such that } \\forall a \\in S: e \\cdot a = a = a \\cdot e $$ is called a monoid. Group Monoid where every element has an inverse : $$ \\forall a \\in S \\; \\exists \\; b \\text{ such that } a \\cdot b = e \\text{, where }e\\text{ is the identity element} $$ is called a group. Links image source wikipedia","title":"Monoid"},{"location":"math/monoid/#abstract-algebra-monoid","text":"","title":"Abstract algebra monoid"},{"location":"math/monoid/#magma","text":"Magma is a set equipped with a binary operation that is closed: \\[ a,b \\in S \\implies a \\cdot b \\in S. \\]","title":"Magma"},{"location":"math/monoid/#semigroup","text":"Magma that is associative : $$ \\forall a, b. c \\in S \\implies (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c) $$ is called a semigroup.","title":"Semigroup"},{"location":"math/monoid/#monoid","text":"Semigroup with identity \\(e\\) : $$ \\exists e \\in S \\text{ such that } \\forall a \\in S: e \\cdot a = a = a \\cdot e $$ is called a monoid.","title":"Monoid"},{"location":"math/monoid/#group","text":"Monoid where every element has an inverse : $$ \\forall a \\in S \\; \\exists \\; b \\text{ such that } a \\cdot b = e \\text{, where }e\\text{ is the identity element} $$ is called a group.","title":"Group"},{"location":"math/monoid/#links","text":"image source wikipedia","title":"Links"},{"location":"math/vandermonde_matrix/","text":"Vandermonde matrix \\[{\\displaystyle V={\\begin{bmatrix}1&x_{0}&x_{0}^{2}&\\dots &x_{0}^{n-1}\\\\1&x_{1}&x_{1}^{2}&\\dots &x_{1}^{n-1}\\\\1&x_{2}&x_{2}^{2}&\\dots &x_{2}^{n-1}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\1&x_{m-1}&x_{m-1}^{2}&\\dots &x_{m-1}^{n-1}\\end{bmatrix}}}\\] Vandermonde matrix maps the vector of coefficients of a polynomial to the vector of the values of the polynomial at the values appearing in the Vandermonde matrix. So coefficients -> samples. The discrete Fourier transform is defined by a specific Vandermonde matrix, the DFT matrix, where the numbers \\(x_i\\) are chosen to be roots of unity. Links: wikipedia","title":"Vandermonde Matrix"},{"location":"math/vandermonde_matrix/#vandermonde-matrix","text":"\\[{\\displaystyle V={\\begin{bmatrix}1&x_{0}&x_{0}^{2}&\\dots &x_{0}^{n-1}\\\\1&x_{1}&x_{1}^{2}&\\dots &x_{1}^{n-1}\\\\1&x_{2}&x_{2}^{2}&\\dots &x_{2}^{n-1}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\1&x_{m-1}&x_{m-1}^{2}&\\dots &x_{m-1}^{n-1}\\end{bmatrix}}}\\] Vandermonde matrix maps the vector of coefficients of a polynomial to the vector of the values of the polynomial at the values appearing in the Vandermonde matrix. So coefficients -> samples. The discrete Fourier transform is defined by a specific Vandermonde matrix, the DFT matrix, where the numbers \\(x_i\\) are chosen to be roots of unity. Links: wikipedia","title":"Vandermonde matrix"}]}