{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notes DFT","title":"Notes"},{"location":"#notes","text":"DFT","title":"Notes"},{"location":"go/io_reader/","text":"io.Reader %%{init: {'theme': 'base', 'themeVariables': { 'darkMode': true, 'primaryColor': '#2c698f', 'lineColor': '#fcd303', 'secondaryColor': '#00ff00', 'tertiaryColor': '#123456', 'primaryTextColor': '#e9ebd2' }}}%% graph LR B[\"[]byte\"] R{io.Reader} str(\"string (text)\") strFn(\"string (filename)\") subgraph ReaderWriter [io.Writer<br>io.Reader] Fd[os.File] buf[bytes.Buffer] end subgraph Reader [io.Reader] br[bytes.Reader] sr[strings.Reader] end B -->|bytes.NewBuffer| buf B -->|bytes.NewReader| br B -->|\"string\"| str B -->|os.WriteFile| strFn str -->|\"[]bytes\"| B R -->|io.ReadAll| B strFn --> |os.ReadFile| B strFn --> |os.Open| Fd str --> |strings.NewReader| sr","title":"io.Reader"},{"location":"go/io_reader/#ioreader","text":"%%{init: {'theme': 'base', 'themeVariables': { 'darkMode': true, 'primaryColor': '#2c698f', 'lineColor': '#fcd303', 'secondaryColor': '#00ff00', 'tertiaryColor': '#123456', 'primaryTextColor': '#e9ebd2' }}}%% graph LR B[\"[]byte\"] R{io.Reader} str(\"string (text)\") strFn(\"string (filename)\") subgraph ReaderWriter [io.Writer<br>io.Reader] Fd[os.File] buf[bytes.Buffer] end subgraph Reader [io.Reader] br[bytes.Reader] sr[strings.Reader] end B -->|bytes.NewBuffer| buf B -->|bytes.NewReader| br B -->|\"string\"| str B -->|os.WriteFile| strFn str -->|\"[]bytes\"| B R -->|io.ReadAll| B strFn --> |os.ReadFile| B strFn --> |os.Open| Fd str --> |strings.NewReader| sr","title":"io.Reader"},{"location":"math/dft_matrix/","text":"DFT matrix DFT matrix is a square Vandermonde matrix , where the numbers \\(x_i\\) are chosen to be roots of unity. For example let \\(n = 8\\) and \\(\\omega = e^{\\frac{-2\\pi i}{8} }= \\frac{1}{\\sqrt{2}} - \\frac{i}{\\sqrt{2}}\\) (primitive 8 th root of unity). We choose the points \\(x_0, \\ldots, x_7\\) to be 8 th roots of unity: \\[\\begin{aligned} x_0& = \\omega ^0 = &1 \\\\ x_1 &= \\omega ^1 = &\\omega\\\\ x_2 &= \\omega ^2 = &-i\\\\ x_3 &= \\omega ^3 = &-i \\omega\\\\ x_4 &= \\omega ^4 = &-1\\\\ x_5 &= \\omega ^5 = &-\\omega\\\\ x_6 &= \\omega ^6 = &i \\\\ x_7 &= \\omega ^7 = &i \\omega \\end{aligned}\\] Then the DFT matrix is (note \\(\\omega^8 = 1\\) ): \\[{\\displaystyle V={\\begin{bmatrix} 1&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}\\\\ 1&\\omega ^{1}&\\omega ^{2}&\\omega ^{3}&\\omega ^{4}&\\omega ^{5}&\\omega ^{6}&\\omega ^{7}\\\\ 1&\\omega ^{2}&\\omega ^{4}&\\omega ^{6}&\\omega ^{8}&\\omega ^{10}&\\omega ^{12}&\\omega ^{14}\\\\ 1&\\omega ^{3}&\\omega ^{6}&\\omega ^{9}&\\omega ^{12}&\\omega ^{15}&\\omega ^{18}&\\omega ^{21}\\\\ 1&\\omega ^{4}&\\omega ^{8}&\\omega ^{12}&\\omega ^{16}&\\omega ^{20}&\\omega ^{24}&\\omega ^{28}\\\\ 1&\\omega ^{5}&\\omega ^{10}&\\omega ^{15}&\\omega ^{20}&\\omega ^{25}&\\omega ^{30}&\\omega ^{35}\\\\ 1&\\omega ^{6}&\\omega ^{12}&\\omega ^{18}&\\omega ^{24}&\\omega ^{30}&\\omega ^{36}&\\omega ^{42}\\\\ 1&\\omega ^{7}&\\omega ^{14}&\\omega ^{21}&\\omega ^{28}&\\omega ^{35}&\\omega ^{42}&\\omega ^{49}\\\\ \\end{bmatrix}}={\\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ \\end{bmatrix}}}\\] Orthogonality of DFT matrix All the columns in \\(V\\) are orthogonal and since it's a change-of-base matrix it means the basis is orthogonal. The dot product of two complex vectors is defined as \\(\\textbf{a} \\cdot \\textbf{b} = \\sum a_j \\overline b_j\\) , where \\(\\overline b_j\\) is the complex conjugate of \\(b_j\\) . Proof: Let \\(\\textbf{a}, \\textbf{b}\\) be two different columns of the DFT matrix and \\(m, l\\; (m\\neq l)\\) the column numbers of \\(\\textbf{a}\\) and \\(\\textbf{b}\\) . \\[\\begin{aligned} \\textbf{a} \\cdot \\textbf{b} &= \\sum_{j=0}^{n-1} a_j \\overline b_j &\\text{definition of complex dot product}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{jm} \\omega^{-jl} &\\text{definition of $\\omega$ in DFT}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{(m-l)j} &\\text{exponential multiplication rules}\\\\ &= \\sum_{j=0}^{n-1} \\omega_{k}^{j} &\\omega^{m-l} \\text{ is a fixed root of unity, call it }\\omega_{k}\\\\ &= \\frac{1 - \\omega_{k}^{n}}{1 - \\omega_{k}} &\\text{geometric series formula, note } \\omega_k \\neq 1\\\\ &= \\frac{1 - 1}{1 - \\omega_k} &{\\omega^n = \\omega^0 = 1}\\\\ &= 0\\end{aligned}\\] QED. Inverse of DFT Complex matrix with orthonormal columns is called Unitary matrix. Since the DFT columns are orthogonal, we can make the DFT matrix Unitary by scaling the columns to be unit-length: \\[U = \\frac{1}{\\sqrt{n}} \\cdot V \\iff \\sqrt{n} \\cdot U = V\\] For unitary matrixes the inverse is just the conjugate transpose: \\[U^{-1} = \\overline U \\iff U\\overline U = I\\] For invertible matrix \\(A\\) we have: \\((kA)^{-1} = k^{-1}A^{-1}\\) . Using this and the previous statements we can get the inverse of \\(V\\) : \\[\\begin{aligned} U^{-1} &= \\overline{U} &\\iff \\\\ (\\frac{1}{\\sqrt{n}} \\cdot V)^{-1} &= \\overline{(\\frac{1}{\\sqrt{n}} \\cdot V)} &\\iff \\\\ \\sqrt{n}V^{-1} &= \\frac{1}{\\sqrt{n}} \\overline{V} &\\iff \\\\ V^{-1} &= \\frac{1}{n} \\cdot \\overline{V} \\end{aligned}\\] So for example the inverse for the DFT with n = 8, we get: \\[{\\displaystyle V^{-1} = \\frac{1}{n} \\cdot \\overline V={ \\frac{1}{n} \\cdot \\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ \\end{bmatrix}}}\\] Links: wikipedia","title":"DFT Matrix"},{"location":"math/dft_matrix/#dft-matrix","text":"DFT matrix is a square Vandermonde matrix , where the numbers \\(x_i\\) are chosen to be roots of unity. For example let \\(n = 8\\) and \\(\\omega = e^{\\frac{-2\\pi i}{8} }= \\frac{1}{\\sqrt{2}} - \\frac{i}{\\sqrt{2}}\\) (primitive 8 th root of unity). We choose the points \\(x_0, \\ldots, x_7\\) to be 8 th roots of unity: \\[\\begin{aligned} x_0& = \\omega ^0 = &1 \\\\ x_1 &= \\omega ^1 = &\\omega\\\\ x_2 &= \\omega ^2 = &-i\\\\ x_3 &= \\omega ^3 = &-i \\omega\\\\ x_4 &= \\omega ^4 = &-1\\\\ x_5 &= \\omega ^5 = &-\\omega\\\\ x_6 &= \\omega ^6 = &i \\\\ x_7 &= \\omega ^7 = &i \\omega \\end{aligned}\\] Then the DFT matrix is (note \\(\\omega^8 = 1\\) ): \\[{\\displaystyle V={\\begin{bmatrix} 1&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}\\\\ 1&\\omega ^{1}&\\omega ^{2}&\\omega ^{3}&\\omega ^{4}&\\omega ^{5}&\\omega ^{6}&\\omega ^{7}\\\\ 1&\\omega ^{2}&\\omega ^{4}&\\omega ^{6}&\\omega ^{8}&\\omega ^{10}&\\omega ^{12}&\\omega ^{14}\\\\ 1&\\omega ^{3}&\\omega ^{6}&\\omega ^{9}&\\omega ^{12}&\\omega ^{15}&\\omega ^{18}&\\omega ^{21}\\\\ 1&\\omega ^{4}&\\omega ^{8}&\\omega ^{12}&\\omega ^{16}&\\omega ^{20}&\\omega ^{24}&\\omega ^{28}\\\\ 1&\\omega ^{5}&\\omega ^{10}&\\omega ^{15}&\\omega ^{20}&\\omega ^{25}&\\omega ^{30}&\\omega ^{35}\\\\ 1&\\omega ^{6}&\\omega ^{12}&\\omega ^{18}&\\omega ^{24}&\\omega ^{30}&\\omega ^{36}&\\omega ^{42}\\\\ 1&\\omega ^{7}&\\omega ^{14}&\\omega ^{21}&\\omega ^{28}&\\omega ^{35}&\\omega ^{42}&\\omega ^{49}\\\\ \\end{bmatrix}}={\\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ \\end{bmatrix}}}\\]","title":"DFT matrix"},{"location":"math/dft_matrix/#orthogonality-of-dft-matrix","text":"All the columns in \\(V\\) are orthogonal and since it's a change-of-base matrix it means the basis is orthogonal. The dot product of two complex vectors is defined as \\(\\textbf{a} \\cdot \\textbf{b} = \\sum a_j \\overline b_j\\) , where \\(\\overline b_j\\) is the complex conjugate of \\(b_j\\) . Proof: Let \\(\\textbf{a}, \\textbf{b}\\) be two different columns of the DFT matrix and \\(m, l\\; (m\\neq l)\\) the column numbers of \\(\\textbf{a}\\) and \\(\\textbf{b}\\) . \\[\\begin{aligned} \\textbf{a} \\cdot \\textbf{b} &= \\sum_{j=0}^{n-1} a_j \\overline b_j &\\text{definition of complex dot product}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{jm} \\omega^{-jl} &\\text{definition of $\\omega$ in DFT}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{(m-l)j} &\\text{exponential multiplication rules}\\\\ &= \\sum_{j=0}^{n-1} \\omega_{k}^{j} &\\omega^{m-l} \\text{ is a fixed root of unity, call it }\\omega_{k}\\\\ &= \\frac{1 - \\omega_{k}^{n}}{1 - \\omega_{k}} &\\text{geometric series formula, note } \\omega_k \\neq 1\\\\ &= \\frac{1 - 1}{1 - \\omega_k} &{\\omega^n = \\omega^0 = 1}\\\\ &= 0\\end{aligned}\\] QED.","title":"Orthogonality of DFT matrix"},{"location":"math/dft_matrix/#inverse-of-dft","text":"Complex matrix with orthonormal columns is called Unitary matrix. Since the DFT columns are orthogonal, we can make the DFT matrix Unitary by scaling the columns to be unit-length: \\[U = \\frac{1}{\\sqrt{n}} \\cdot V \\iff \\sqrt{n} \\cdot U = V\\] For unitary matrixes the inverse is just the conjugate transpose: \\[U^{-1} = \\overline U \\iff U\\overline U = I\\] For invertible matrix \\(A\\) we have: \\((kA)^{-1} = k^{-1}A^{-1}\\) . Using this and the previous statements we can get the inverse of \\(V\\) : \\[\\begin{aligned} U^{-1} &= \\overline{U} &\\iff \\\\ (\\frac{1}{\\sqrt{n}} \\cdot V)^{-1} &= \\overline{(\\frac{1}{\\sqrt{n}} \\cdot V)} &\\iff \\\\ \\sqrt{n}V^{-1} &= \\frac{1}{\\sqrt{n}} \\overline{V} &\\iff \\\\ V^{-1} &= \\frac{1}{n} \\cdot \\overline{V} \\end{aligned}\\] So for example the inverse for the DFT with n = 8, we get: \\[{\\displaystyle V^{-1} = \\frac{1}{n} \\cdot \\overline V={ \\frac{1}{n} \\cdot \\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ \\end{bmatrix}}}\\] Links: wikipedia","title":"Inverse of DFT"},{"location":"math/discrete_fft/","text":"Discrete Fast Fourier Transform FFT is fast way to calculate the DFT matrix multiplication. Info DFT is basically evaluating n points of a (n-1)-degree polynomial, thus naive time complexity is O(n^2). FFT gets this down to O(n log n) by exploiting symmetries of roots of unity and even functions. Key Idea: Split polynomial into even and odd terms \\(A(x) = A_e(x) + A_o(x)\\) Even terms form an even function: \\(A_e(x) = A_e(-x)\\) Odd terms we can factor x out and get even function Recursively compute \\(A_e(y) \\text{ and } A_o(y) \\text{ for } y \\in X^2 = \\{x^2 | x \\in X\\}\\) Because we are using roots of unity and we have even functions the number of items in this set stays small enough Base case is when the degree is 0, so \\(A\\) is a constant Combine \\(A(x) = A_e(x^2) + x \\cdot A_o(x^2)\\) Example Let \\(A(x) = 2x^7 + 3x^6 + 4x^5 + 5x^4 + 6x^3 + 7x^2 + 8x + 9\\) Split A into even and odd terms and substitute \\(x^2 = y\\) and we get two degree 3 polynomials (instead of one degree 7): -> even terms \\(A_e(x) = 3x^6 + 5x^4 + 7x^2 + 9 \\implies A_e(y) = 3y^3 + 5y^2 + 7y + 9\\) -> odd terms \\(A_o(x) = 2x^7 + 4x^5 + 6x^3 + 8x = x (2x^6 + 4x^4 + 6x^2 + 8) \\implies A_o(y) = 2y^3 + 4y^2 + 6y + 8\\) Overall this is just \\(A(x) = 3(x^2)^3 + 5(x^2)^2 + 7(x^2) + 9 + x \\cdot (2(x^2)^3 + 4(x^2)^2 + 6(x^2) + 8)\\) Another way to think about the DFT as a set of dot products between the signal and each base function (so conceptually it is in no way different than any other linear coordinate transform). And the FFT is a way to avoid explicitly computing every single dot product. Python implementation from math import e , pi from typing import List import numpy as np def fft ( p : List [ complex ]) -> List [ complex ]: # radix 2 Cooley-Tukey algorithm n = len ( p ) if not n and ( not ( n & ( n - 1 ))): # check if n is power of 2 raise ValueError ( \"This implementation requires arrays with length power of two\" ) if n == 1 : return p y_even , y_odd = fft ( p [:: 2 ]), fft ( p [ 1 :: 2 ]) omega = e ** ( - 2 j * pi / n ) # primitive nth root of unity y = [ 0 ] * n for i in range ( n // 2 ): y [ i ] = y_even [ i ] + omega ** i * y_odd [ i ] y [ i + n // 2 ] = y_even [ i ] - omega ** i * y_odd [ i ] return y def ifft ( p : List [ complex ]) -> List [ complex ]: # Take complex conjugates p = [ np . conj ( x ) for x in p ] # Calculate normal fft p = fft ( p ) # Take complex conjugates again and scale by 1/n n = len ( p ) return [ 1 / n * np . conj ( x ) for x in p ] Links Even and odd functions - wikipedia The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? - youtube Lecture 8 - Algorithms: The Fast Fourier Transform (FFT) - youtube 26. Complex Matrices; Fast Fourier Transform","title":"Discrete FFT"},{"location":"math/discrete_fft/#discrete-fast-fourier-transform","text":"FFT is fast way to calculate the DFT matrix multiplication. Info DFT is basically evaluating n points of a (n-1)-degree polynomial, thus naive time complexity is O(n^2). FFT gets this down to O(n log n) by exploiting symmetries of roots of unity and even functions. Key Idea: Split polynomial into even and odd terms \\(A(x) = A_e(x) + A_o(x)\\) Even terms form an even function: \\(A_e(x) = A_e(-x)\\) Odd terms we can factor x out and get even function Recursively compute \\(A_e(y) \\text{ and } A_o(y) \\text{ for } y \\in X^2 = \\{x^2 | x \\in X\\}\\) Because we are using roots of unity and we have even functions the number of items in this set stays small enough Base case is when the degree is 0, so \\(A\\) is a constant Combine \\(A(x) = A_e(x^2) + x \\cdot A_o(x^2)\\) Example Let \\(A(x) = 2x^7 + 3x^6 + 4x^5 + 5x^4 + 6x^3 + 7x^2 + 8x + 9\\) Split A into even and odd terms and substitute \\(x^2 = y\\) and we get two degree 3 polynomials (instead of one degree 7): -> even terms \\(A_e(x) = 3x^6 + 5x^4 + 7x^2 + 9 \\implies A_e(y) = 3y^3 + 5y^2 + 7y + 9\\) -> odd terms \\(A_o(x) = 2x^7 + 4x^5 + 6x^3 + 8x = x (2x^6 + 4x^4 + 6x^2 + 8) \\implies A_o(y) = 2y^3 + 4y^2 + 6y + 8\\) Overall this is just \\(A(x) = 3(x^2)^3 + 5(x^2)^2 + 7(x^2) + 9 + x \\cdot (2(x^2)^3 + 4(x^2)^2 + 6(x^2) + 8)\\) Another way to think about the DFT as a set of dot products between the signal and each base function (so conceptually it is in no way different than any other linear coordinate transform). And the FFT is a way to avoid explicitly computing every single dot product. Python implementation from math import e , pi from typing import List import numpy as np def fft ( p : List [ complex ]) -> List [ complex ]: # radix 2 Cooley-Tukey algorithm n = len ( p ) if not n and ( not ( n & ( n - 1 ))): # check if n is power of 2 raise ValueError ( \"This implementation requires arrays with length power of two\" ) if n == 1 : return p y_even , y_odd = fft ( p [:: 2 ]), fft ( p [ 1 :: 2 ]) omega = e ** ( - 2 j * pi / n ) # primitive nth root of unity y = [ 0 ] * n for i in range ( n // 2 ): y [ i ] = y_even [ i ] + omega ** i * y_odd [ i ] y [ i + n // 2 ] = y_even [ i ] - omega ** i * y_odd [ i ] return y def ifft ( p : List [ complex ]) -> List [ complex ]: # Take complex conjugates p = [ np . conj ( x ) for x in p ] # Calculate normal fft p = fft ( p ) # Take complex conjugates again and scale by 1/n n = len ( p ) return [ 1 / n * np . conj ( x ) for x in p ]","title":"Discrete Fast Fourier Transform"},{"location":"math/discrete_fft/#links","text":"Even and odd functions - wikipedia The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? - youtube Lecture 8 - Algorithms: The Fast Fourier Transform (FFT) - youtube 26. Complex Matrices; Fast Fourier Transform","title":"Links"},{"location":"math/discrete_fourier_transform/","text":"Discrete Fourier Transform Let's consider polynomial: \\(A(x) = a_0 \\cdot x^0 + a_1 \\cdot x^1 + a_2 \\cdot x^2 + ... + a_{n-1} \\cdot x^{n-1}\\) There are 3 different representations for this polynomial: Coefficient vector: \\(a_0 \\cdot x^0 + a_1 \\cdot x^1 + ... + a_{n-1} \\cdot x^{n-1}\\) Roots: \\(r_0, r_1, ..., r_{n-1}\\) such that \\(A = c \\cdot (x-r_0) \\cdot (x - r_1) \\cdots (x - r_{n-1})\\) Samples of the polynomial: \\((x_k, y_k)\\) for \\(\\; k=0, 1, ...n-1\\) where \\(A(x_k) = y_k \\; \\forall k\\) and \\(x_k\\) 's are distinct We can perform 3 different operation on the polynomials: Evaluate one polynomial Add two polynomials Multiply two polynomials The table for complexity for these operations based on the representation Operation Coefficients Roots Samples Evaluate O(n) O(n) O(n^2) Add O(n) \\(\\infty\\) O(n) Multiply O(n^2) O(n) O(n) Discrete fourier transform is the transform between coefficient and sample representations. Using FFT (fast fourier transform) algorithm we can perform this operation in O(n log n) time. The inverse operation also has same time complexity. The idea is that instead of performing O(n^2) operation, we will use FFT to transform the representation, then do the operation in O(n) time, then transform back with IFFT. This way we can perform all 3 operations in O(n log n) time or less. We can calculate the DFT with DFT Matrix or more efficiently with using FFT Links Divide & Conquer: FFT MIT OpenCourseWare DSP Lecture 10: The Discrete Fourier Transform","title":"Discrete FT"},{"location":"math/discrete_fourier_transform/#discrete-fourier-transform","text":"Let's consider polynomial: \\(A(x) = a_0 \\cdot x^0 + a_1 \\cdot x^1 + a_2 \\cdot x^2 + ... + a_{n-1} \\cdot x^{n-1}\\) There are 3 different representations for this polynomial: Coefficient vector: \\(a_0 \\cdot x^0 + a_1 \\cdot x^1 + ... + a_{n-1} \\cdot x^{n-1}\\) Roots: \\(r_0, r_1, ..., r_{n-1}\\) such that \\(A = c \\cdot (x-r_0) \\cdot (x - r_1) \\cdots (x - r_{n-1})\\) Samples of the polynomial: \\((x_k, y_k)\\) for \\(\\; k=0, 1, ...n-1\\) where \\(A(x_k) = y_k \\; \\forall k\\) and \\(x_k\\) 's are distinct We can perform 3 different operation on the polynomials: Evaluate one polynomial Add two polynomials Multiply two polynomials The table for complexity for these operations based on the representation Operation Coefficients Roots Samples Evaluate O(n) O(n) O(n^2) Add O(n) \\(\\infty\\) O(n) Multiply O(n^2) O(n) O(n) Discrete fourier transform is the transform between coefficient and sample representations. Using FFT (fast fourier transform) algorithm we can perform this operation in O(n log n) time. The inverse operation also has same time complexity. The idea is that instead of performing O(n^2) operation, we will use FFT to transform the representation, then do the operation in O(n) time, then transform back with IFFT. This way we can perform all 3 operations in O(n log n) time or less. We can calculate the DFT with DFT Matrix or more efficiently with using FFT","title":"Discrete Fourier Transform"},{"location":"math/discrete_fourier_transform/#links","text":"Divide & Conquer: FFT MIT OpenCourseWare DSP Lecture 10: The Discrete Fourier Transform","title":"Links"},{"location":"math/monoid/","text":"Abstract algebra monoid Magma Magma is a set equipped with a binary operation that is closed: \\[ a,b \\in S \\implies a \\cdot b \\in S. \\] Semigroup Magma that is associative : $$ \\forall a, b. c \\in S \\implies (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c) $$ is called a semigroup. Monoid Semigroup with identity \\(e\\) : $$ \\exists e \\in S \\text{ such that } \\forall a \\in S: e \\cdot a = a = a \\cdot e $$ is called a monoid. Group Monoid where every element has an inverse : $$ \\forall a \\in S \\; \\exists \\; b \\text{ such that } a \\cdot b = e \\text{, where }e\\text{ is the identity element} $$ is called a group. Links image source wikipedia","title":"Monoid"},{"location":"math/monoid/#abstract-algebra-monoid","text":"","title":"Abstract algebra monoid"},{"location":"math/monoid/#magma","text":"Magma is a set equipped with a binary operation that is closed: \\[ a,b \\in S \\implies a \\cdot b \\in S. \\]","title":"Magma"},{"location":"math/monoid/#semigroup","text":"Magma that is associative : $$ \\forall a, b. c \\in S \\implies (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c) $$ is called a semigroup.","title":"Semigroup"},{"location":"math/monoid/#monoid","text":"Semigroup with identity \\(e\\) : $$ \\exists e \\in S \\text{ such that } \\forall a \\in S: e \\cdot a = a = a \\cdot e $$ is called a monoid.","title":"Monoid"},{"location":"math/monoid/#group","text":"Monoid where every element has an inverse : $$ \\forall a \\in S \\; \\exists \\; b \\text{ such that } a \\cdot b = e \\text{, where }e\\text{ is the identity element} $$ is called a group.","title":"Group"},{"location":"math/monoid/#links","text":"image source wikipedia","title":"Links"},{"location":"math/vandermonde_matrix/","text":"Vandermonde matrix \\[{\\displaystyle V={\\begin{bmatrix}1&x_{0}&x_{0}^{2}&\\dots &x_{0}^{n-1}\\\\1&x_{1}&x_{1}^{2}&\\dots &x_{1}^{n-1}\\\\1&x_{2}&x_{2}^{2}&\\dots &x_{2}^{n-1}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\1&x_{m-1}&x_{m-1}^{2}&\\dots &x_{m-1}^{n-1}\\end{bmatrix}}}\\] Vandermonde matrix maps the vector of coefficients of a polynomial to the vector of the values of the polynomial at the values appearing in the Vandermonde matrix. So coefficients -> samples. The discrete Fourier transform is defined by a specific Vandermonde matrix, the DFT matrix, where the numbers \\(x_i\\) are chosen to be roots of unity. Links: wikipedia","title":"Vandermonde Matrix"},{"location":"math/vandermonde_matrix/#vandermonde-matrix","text":"\\[{\\displaystyle V={\\begin{bmatrix}1&x_{0}&x_{0}^{2}&\\dots &x_{0}^{n-1}\\\\1&x_{1}&x_{1}^{2}&\\dots &x_{1}^{n-1}\\\\1&x_{2}&x_{2}^{2}&\\dots &x_{2}^{n-1}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\1&x_{m-1}&x_{m-1}^{2}&\\dots &x_{m-1}^{n-1}\\end{bmatrix}}}\\] Vandermonde matrix maps the vector of coefficients of a polynomial to the vector of the values of the polynomial at the values appearing in the Vandermonde matrix. So coefficients -> samples. The discrete Fourier transform is defined by a specific Vandermonde matrix, the DFT matrix, where the numbers \\(x_i\\) are chosen to be roots of unity. Links: wikipedia","title":"Vandermonde matrix"}]}