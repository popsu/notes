{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notes DFT","title":"Notes"},{"location":"#notes","text":"DFT","title":"Notes"},{"location":"go/io_reader/","text":"io.Reader %%{init: {'theme': 'base', 'themeVariables': { 'darkMode': true, 'primaryColor': '#2c698f', 'lineColor': '#fcd303', 'secondaryColor': '#00ff00', 'tertiaryColor': '#123456', 'primaryTextColor': '#e9ebd2' }}}%% graph LR B[\"[]byte\"] R{io.Reader} str(\"string (text)\") strFn(\"string (filename)\") subgraph ReaderWriter [io.Writer<br>io.Reader] Fd[os.File] buf[bytes.Buffer] end subgraph Reader [io.Reader] br[bytes.Reader] sr[strings.Reader] end B -->|bytes.NewBuffer| buf B -->|bytes.NewReader| br B -->|\"string\"| str B -->|os.WriteFile| strFn str -->|\"[]bytes\"| B R -->|io.ReadAll| B strFn --> |os.ReadFile| B strFn --> |os.Open| Fd str --> |strings.NewReader| sr","title":"io.Reader"},{"location":"go/io_reader/#ioreader","text":"%%{init: {'theme': 'base', 'themeVariables': { 'darkMode': true, 'primaryColor': '#2c698f', 'lineColor': '#fcd303', 'secondaryColor': '#00ff00', 'tertiaryColor': '#123456', 'primaryTextColor': '#e9ebd2' }}}%% graph LR B[\"[]byte\"] R{io.Reader} str(\"string (text)\") strFn(\"string (filename)\") subgraph ReaderWriter [io.Writer<br>io.Reader] Fd[os.File] buf[bytes.Buffer] end subgraph Reader [io.Reader] br[bytes.Reader] sr[strings.Reader] end B -->|bytes.NewBuffer| buf B -->|bytes.NewReader| br B -->|\"string\"| str B -->|os.WriteFile| strFn str -->|\"[]bytes\"| B R -->|io.ReadAll| B strFn --> |os.ReadFile| B strFn --> |os.Open| Fd str --> |strings.NewReader| sr","title":"io.Reader"},{"location":"math/dft_matrix/","text":"DFT matrix DFT matrix is a square Vandermonde matrix , where the numbers \\(x_i\\) are chosen to be roots of unity. For example let \\(n = 8\\) and \\(\\omega = e^{\\frac{-2\\pi i}{8} }= \\frac{1}{\\sqrt{2}} - \\frac{i}{\\sqrt{2}}\\) (primitive 8 th root of unity). We choose the points \\(x_0, \\ldots, x_7\\) to be 8 th roots of unity: \\[\\begin{aligned} x_0& = \\omega ^0 = &1 \\\\ x_1 &= \\omega ^1 = &\\omega\\\\ x_2 &= \\omega ^2 = &-i\\\\ x_3 &= \\omega ^3 = &-i \\omega\\\\ x_4 &= \\omega ^4 = &-1\\\\ x_5 &= \\omega ^5 = &-\\omega\\\\ x_6 &= \\omega ^6 = &i \\\\ x_7 &= \\omega ^7 = &i \\omega \\end{aligned}\\] Then the DFT matrix is (note \\(\\omega^8 = 1\\) ): \\[{\\displaystyle V={\\begin{bmatrix} 1&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}\\\\ 1&\\omega ^{1}&\\omega ^{2}&\\omega ^{3}&\\omega ^{4}&\\omega ^{5}&\\omega ^{6}&\\omega ^{7}\\\\ 1&\\omega ^{2}&\\omega ^{4}&\\omega ^{6}&\\omega ^{8}&\\omega ^{10}&\\omega ^{12}&\\omega ^{14}\\\\ 1&\\omega ^{3}&\\omega ^{6}&\\omega ^{9}&\\omega ^{12}&\\omega ^{15}&\\omega ^{18}&\\omega ^{21}\\\\ 1&\\omega ^{4}&\\omega ^{8}&\\omega ^{12}&\\omega ^{16}&\\omega ^{20}&\\omega ^{24}&\\omega ^{28}\\\\ 1&\\omega ^{5}&\\omega ^{10}&\\omega ^{15}&\\omega ^{20}&\\omega ^{25}&\\omega ^{30}&\\omega ^{35}\\\\ 1&\\omega ^{6}&\\omega ^{12}&\\omega ^{18}&\\omega ^{24}&\\omega ^{30}&\\omega ^{36}&\\omega ^{42}\\\\ 1&\\omega ^{7}&\\omega ^{14}&\\omega ^{21}&\\omega ^{28}&\\omega ^{35}&\\omega ^{42}&\\omega ^{49}\\\\ \\end{bmatrix}}={\\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ \\end{bmatrix}}}\\] Orthogonality of DFT matrix All the columns in \\(V\\) are orthogonal and since it's a change-of-base matrix it means the basis is orthogonal. The dot product of two complex vectors is defined as \\(\\textbf{a} \\cdot \\textbf{b} = \\sum a_j \\overline b_j\\) , where \\(\\overline b_j\\) is the complex conjugate of \\(b_j\\) . Proof: Let \\(\\textbf{a}, \\textbf{b}\\) be two different columns of the DFT matrix and \\(m, l\\; (m\\neq l)\\) the column numbers of \\(\\textbf{a}\\) and \\(\\textbf{b}\\) . \\[\\begin{aligned} \\textbf{a} \\cdot \\textbf{b} &= \\sum_{j=0}^{n-1} a_j \\overline b_j &\\text{definition of complex dot product}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{jm} \\omega^{-jl} &\\text{definition of $\\omega$ in DFT}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{(m-l)j} &\\text{exponential multiplication rules}\\\\ &= \\sum_{j=0}^{n-1} \\omega_{k}^{j} &\\omega^{m-l} \\text{ is a fixed root of unity, call it }\\omega_{k}\\\\ &= \\frac{1 - \\omega_{k}^{n}}{1 - \\omega_{k}} &\\text{geometric series formula, note } \\omega_k \\neq 1\\\\ &= \\frac{1 - 1}{1 - \\omega_k} &{\\omega^n = \\omega^0 = 1}\\\\ &= 0\\end{aligned}\\] QED. Inverse of DFT Complex matrix with orthonormal columns is called Unitary matrix. Since the DFT columns are orthogonal, we can make the DFT matrix Unitary by scaling the columns to be unit-length: \\[U = \\frac{1}{\\sqrt{n}} \\cdot V \\iff \\sqrt{n} \\cdot U = V\\] For unitary matrixes the inverse is just the conjugate transpose: \\[U^{-1} = \\overline U \\iff U\\overline U = I\\] For invertible matrix \\(A\\) we have: \\((kA)^{-1} = k^{-1}A^{-1}\\) . Using this and the previous statements we can get the inverse of \\(V\\) : \\[\\begin{aligned} U^{-1} &= \\overline{U} &\\iff \\\\ (\\frac{1}{\\sqrt{n}} \\cdot V)^{-1} &= \\overline{(\\frac{1}{\\sqrt{n}} \\cdot V)} &\\iff \\\\ \\sqrt{n}V^{-1} &= \\frac{1}{\\sqrt{n}} \\overline{V} &\\iff \\\\ V^{-1} &= \\frac{1}{n} \\cdot \\overline{V} \\end{aligned}\\] So for example the inverse for the DFT with n = 8, we get: \\[{\\displaystyle V^{-1} = \\frac{1}{n} \\cdot \\overline V={ \\frac{1}{n} \\cdot \\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ \\end{bmatrix}}}\\] Links: wikipedia","title":"DFT Matrix"},{"location":"math/dft_matrix/#dft-matrix","text":"DFT matrix is a square Vandermonde matrix , where the numbers \\(x_i\\) are chosen to be roots of unity. For example let \\(n = 8\\) and \\(\\omega = e^{\\frac{-2\\pi i}{8} }= \\frac{1}{\\sqrt{2}} - \\frac{i}{\\sqrt{2}}\\) (primitive 8 th root of unity). We choose the points \\(x_0, \\ldots, x_7\\) to be 8 th roots of unity: \\[\\begin{aligned} x_0& = \\omega ^0 = &1 \\\\ x_1 &= \\omega ^1 = &\\omega\\\\ x_2 &= \\omega ^2 = &-i\\\\ x_3 &= \\omega ^3 = &-i \\omega\\\\ x_4 &= \\omega ^4 = &-1\\\\ x_5 &= \\omega ^5 = &-\\omega\\\\ x_6 &= \\omega ^6 = &i \\\\ x_7 &= \\omega ^7 = &i \\omega \\end{aligned}\\] Then the DFT matrix is (note \\(\\omega^8 = 1\\) ): \\[{\\displaystyle V={\\begin{bmatrix} 1&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}&\\omega ^{0}\\\\ 1&\\omega ^{1}&\\omega ^{2}&\\omega ^{3}&\\omega ^{4}&\\omega ^{5}&\\omega ^{6}&\\omega ^{7}\\\\ 1&\\omega ^{2}&\\omega ^{4}&\\omega ^{6}&\\omega ^{8}&\\omega ^{10}&\\omega ^{12}&\\omega ^{14}\\\\ 1&\\omega ^{3}&\\omega ^{6}&\\omega ^{9}&\\omega ^{12}&\\omega ^{15}&\\omega ^{18}&\\omega ^{21}\\\\ 1&\\omega ^{4}&\\omega ^{8}&\\omega ^{12}&\\omega ^{16}&\\omega ^{20}&\\omega ^{24}&\\omega ^{28}\\\\ 1&\\omega ^{5}&\\omega ^{10}&\\omega ^{15}&\\omega ^{20}&\\omega ^{25}&\\omega ^{30}&\\omega ^{35}\\\\ 1&\\omega ^{6}&\\omega ^{12}&\\omega ^{18}&\\omega ^{24}&\\omega ^{30}&\\omega ^{36}&\\omega ^{42}\\\\ 1&\\omega ^{7}&\\omega ^{14}&\\omega ^{21}&\\omega ^{28}&\\omega ^{35}&\\omega ^{42}&\\omega ^{49}\\\\ \\end{bmatrix}}={\\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ \\end{bmatrix}}}\\]","title":"DFT matrix"},{"location":"math/dft_matrix/#orthogonality-of-dft-matrix","text":"All the columns in \\(V\\) are orthogonal and since it's a change-of-base matrix it means the basis is orthogonal. The dot product of two complex vectors is defined as \\(\\textbf{a} \\cdot \\textbf{b} = \\sum a_j \\overline b_j\\) , where \\(\\overline b_j\\) is the complex conjugate of \\(b_j\\) . Proof: Let \\(\\textbf{a}, \\textbf{b}\\) be two different columns of the DFT matrix and \\(m, l\\; (m\\neq l)\\) the column numbers of \\(\\textbf{a}\\) and \\(\\textbf{b}\\) . \\[\\begin{aligned} \\textbf{a} \\cdot \\textbf{b} &= \\sum_{j=0}^{n-1} a_j \\overline b_j &\\text{definition of complex dot product}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{jm} \\omega^{-jl} &\\text{definition of $\\omega$ in DFT}\\\\ &= \\sum_{j=0}^{n-1} \\omega^{(m-l)j} &\\text{exponential multiplication rules}\\\\ &= \\sum_{j=0}^{n-1} \\omega_{k}^{j} &\\omega^{m-l} \\text{ is a fixed root of unity, call it }\\omega_{k}\\\\ &= \\frac{1 - \\omega_{k}^{n}}{1 - \\omega_{k}} &\\text{geometric series formula, note } \\omega_k \\neq 1\\\\ &= \\frac{1 - 1}{1 - \\omega_k} &{\\omega^n = \\omega^0 = 1}\\\\ &= 0\\end{aligned}\\] QED.","title":"Orthogonality of DFT matrix"},{"location":"math/dft_matrix/#inverse-of-dft","text":"Complex matrix with orthonormal columns is called Unitary matrix. Since the DFT columns are orthogonal, we can make the DFT matrix Unitary by scaling the columns to be unit-length: \\[U = \\frac{1}{\\sqrt{n}} \\cdot V \\iff \\sqrt{n} \\cdot U = V\\] For unitary matrixes the inverse is just the conjugate transpose: \\[U^{-1} = \\overline U \\iff U\\overline U = I\\] For invertible matrix \\(A\\) we have: \\((kA)^{-1} = k^{-1}A^{-1}\\) . Using this and the previous statements we can get the inverse of \\(V\\) : \\[\\begin{aligned} U^{-1} &= \\overline{U} &\\iff \\\\ (\\frac{1}{\\sqrt{n}} \\cdot V)^{-1} &= \\overline{(\\frac{1}{\\sqrt{n}} \\cdot V)} &\\iff \\\\ \\sqrt{n}V^{-1} &= \\frac{1}{\\sqrt{n}} \\overline{V} &\\iff \\\\ V^{-1} &= \\frac{1}{n} \\cdot \\overline{V} \\end{aligned}\\] So for example the inverse for the DFT with n = 8, we get: \\[{\\displaystyle V^{-1} = \\frac{1}{n} \\cdot \\overline V={ \\frac{1}{n} \\cdot \\begin{bmatrix} 1&1&1&1&1&1&1&1\\\\ 1&i\\omega &i&-\\omega &-1&-i\\omega &-i&\\omega \\\\ 1&i&-1&-i&1&i&-1&-i\\\\ 1&-\\omega &-i&i\\omega &-1&\\omega &i&-i\\omega \\\\ 1&-1&1&-1&1&-1&1&-1\\\\ 1&-i\\omega &i&\\omega &-1&i\\omega &-i&-\\omega \\\\ 1&-i&-1&i&1&-i&-1&i\\\\ 1&\\omega &-i&-i\\omega &-1&-\\omega &i&i\\omega \\\\ \\end{bmatrix}}}\\] Links: wikipedia","title":"Inverse of DFT"},{"location":"math/discrete_fft/","text":"Discrete Fast Fourier Transform FFT is fast way to calculate the DFT matrix multiplication. Info DFT is basically evaluating n points of a (n-1)-degree polynomial, thus naive time complexity is O(n^2). FFT gets this down to O(n log n) by exploiting symmetries of roots of unity and even functions. Key Idea: Split polynomial into even and odd terms \\(A(x) = A_e(x) + A_o(x)\\) Even terms form an even function: \\(A_e(x) = A_e(-x)\\) Odd terms we can factor x out and get even function Recursively compute \\(A_e(y) \\text{ and } A_o(y) \\text{ for } y \\in X^2 = \\{x^2 | x \\in X\\}\\) Because we are using roots of unity and we have even functions the number of items in this set stays small enough Base case is when the degree is 0, so \\(A\\) is a constant Combine \\(A(x) = A_e(x^2) + x \\cdot A_o(x^2)\\) Example Let \\(A(x) = 2x^7 + 3x^6 + 4x^5 + 5x^4 + 6x^3 + 7x^2 + 8x + 9\\) Split A into even and odd terms and substitute \\(x^2 = y\\) and we get two degree 3 polynomials (instead of one degree 7): -> even terms \\(A_e(x) = 3x^6 + 5x^4 + 7x^2 + 9 \\implies A_e(y) = 3y^3 + 5y^2 + 7y + 9\\) -> odd terms \\(A_o(x) = 2x^7 + 4x^5 + 6x^3 + 8x = x (2x^6 + 4x^4 + 6x^2 + 8) \\implies A_o(y) = 2y^3 + 4y^2 + 6y + 8\\) Overall this is just \\(A(x) = 3(x^2)^3 + 5(x^2)^2 + 7(x^2) + 9 + x \\cdot (2(x^2)^3 + 4(x^2)^2 + 6(x^2) + 8)\\) Another way to think about the DFT as a set of dot products between the signal and each base function (so conceptually it is in no way different than any other linear coordinate transform). And the FFT is a way to avoid explicitly computing every single dot product. Python implementation from math import e , pi from typing import List import numpy as np def fft ( p : List [ complex ]) -> List [ complex ]: # radix 2 Cooley-Tukey algorithm n = len ( p ) if not n and ( not ( n & ( n - 1 ))): # check if n is power of 2 raise ValueError ( \"This implementation requires arrays with length power of two\" ) if n == 1 : return p y_even , y_odd = fft ( p [:: 2 ]), fft ( p [ 1 :: 2 ]) omega = e ** ( - 2 j * pi / n ) # primitive nth root of unity y = [ 0 ] * n for i in range ( n // 2 ): y [ i ] = y_even [ i ] + omega ** i * y_odd [ i ] y [ i + n // 2 ] = y_even [ i ] - omega ** i * y_odd [ i ] return y def ifft ( p : List [ complex ]) -> List [ complex ]: # Take complex conjugates p = [ np . conj ( x ) for x in p ] # Calculate normal fft p = fft ( p ) # Take complex conjugates again and scale by 1/n n = len ( p ) return [ 1 / n * np . conj ( x ) for x in p ] Links Even and odd functions - wikipedia The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? - youtube Lecture 8 - Algorithms: The Fast Fourier Transform (FFT) - youtube 26. Complex Matrices; Fast Fourier Transform","title":"Discrete FFT"},{"location":"math/discrete_fft/#discrete-fast-fourier-transform","text":"FFT is fast way to calculate the DFT matrix multiplication. Info DFT is basically evaluating n points of a (n-1)-degree polynomial, thus naive time complexity is O(n^2). FFT gets this down to O(n log n) by exploiting symmetries of roots of unity and even functions. Key Idea: Split polynomial into even and odd terms \\(A(x) = A_e(x) + A_o(x)\\) Even terms form an even function: \\(A_e(x) = A_e(-x)\\) Odd terms we can factor x out and get even function Recursively compute \\(A_e(y) \\text{ and } A_o(y) \\text{ for } y \\in X^2 = \\{x^2 | x \\in X\\}\\) Because we are using roots of unity and we have even functions the number of items in this set stays small enough Base case is when the degree is 0, so \\(A\\) is a constant Combine \\(A(x) = A_e(x^2) + x \\cdot A_o(x^2)\\) Example Let \\(A(x) = 2x^7 + 3x^6 + 4x^5 + 5x^4 + 6x^3 + 7x^2 + 8x + 9\\) Split A into even and odd terms and substitute \\(x^2 = y\\) and we get two degree 3 polynomials (instead of one degree 7): -> even terms \\(A_e(x) = 3x^6 + 5x^4 + 7x^2 + 9 \\implies A_e(y) = 3y^3 + 5y^2 + 7y + 9\\) -> odd terms \\(A_o(x) = 2x^7 + 4x^5 + 6x^3 + 8x = x (2x^6 + 4x^4 + 6x^2 + 8) \\implies A_o(y) = 2y^3 + 4y^2 + 6y + 8\\) Overall this is just \\(A(x) = 3(x^2)^3 + 5(x^2)^2 + 7(x^2) + 9 + x \\cdot (2(x^2)^3 + 4(x^2)^2 + 6(x^2) + 8)\\) Another way to think about the DFT as a set of dot products between the signal and each base function (so conceptually it is in no way different than any other linear coordinate transform). And the FFT is a way to avoid explicitly computing every single dot product. Python implementation from math import e , pi from typing import List import numpy as np def fft ( p : List [ complex ]) -> List [ complex ]: # radix 2 Cooley-Tukey algorithm n = len ( p ) if not n and ( not ( n & ( n - 1 ))): # check if n is power of 2 raise ValueError ( \"This implementation requires arrays with length power of two\" ) if n == 1 : return p y_even , y_odd = fft ( p [:: 2 ]), fft ( p [ 1 :: 2 ]) omega = e ** ( - 2 j * pi / n ) # primitive nth root of unity y = [ 0 ] * n for i in range ( n // 2 ): y [ i ] = y_even [ i ] + omega ** i * y_odd [ i ] y [ i + n // 2 ] = y_even [ i ] - omega ** i * y_odd [ i ] return y def ifft ( p : List [ complex ]) -> List [ complex ]: # Take complex conjugates p = [ np . conj ( x ) for x in p ] # Calculate normal fft p = fft ( p ) # Take complex conjugates again and scale by 1/n n = len ( p ) return [ 1 / n * np . conj ( x ) for x in p ]","title":"Discrete Fast Fourier Transform"},{"location":"math/discrete_fft/#links","text":"Even and odd functions - wikipedia The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? - youtube Lecture 8 - Algorithms: The Fast Fourier Transform (FFT) - youtube 26. Complex Matrices; Fast Fourier Transform","title":"Links"},{"location":"math/discrete_fourier_transform/","text":"Discrete Fourier Transform Let's consider polynomial: \\(A(x) = a_0 \\cdot x^0 + a_1 \\cdot x^1 + a_2 \\cdot x^2 + ... + a_{n-1} \\cdot x^{n-1}\\) There are 3 different representations for this polynomial: Coefficient vector: \\(a_0 \\cdot x^0 + a_1 \\cdot x^1 + ... + a_{n-1} \\cdot x^{n-1}\\) Roots: \\(r_0, r_1, ..., r_{n-1}\\) such that \\(A = c \\cdot (x-r_0) \\cdot (x - r_1) \\cdots (x - r_{n-1})\\) Samples of the polynomial: \\((x_k, y_k)\\) for \\(\\; k=0, 1, ...n-1\\) where \\(A(x_k) = y_k \\; \\forall k\\) and \\(x_k\\) 's are distinct We can perform 3 different operation on the polynomials: Evaluate one polynomial Add two polynomials Multiply two polynomials The table for complexity for these operations based on the representation Operation Coefficients Roots Samples Evaluate O(n) O(n) O(n^2) Add O(n) \\(\\infty\\) O(n) Multiply O(n^2) O(n) O(n) Discrete fourier transform is the transform between coefficient and sample representations. Using FFT (fast fourier transform) algorithm we can perform this operation in O(n log n) time. The inverse operation also has same time complexity. The idea is that instead of performing O(n^2) operation, we will use FFT to transform the representation, then do the operation in O(n) time, then transform back with IFFT. This way we can perform all 3 operations in O(n log n) time or less. We can calculate the DFT with DFT Matrix or more efficiently with using FFT Links Divide & Conquer: FFT MIT OpenCourseWare DSP Lecture 10: The Discrete Fourier Transform","title":"Discrete FT"},{"location":"math/discrete_fourier_transform/#discrete-fourier-transform","text":"Let's consider polynomial: \\(A(x) = a_0 \\cdot x^0 + a_1 \\cdot x^1 + a_2 \\cdot x^2 + ... + a_{n-1} \\cdot x^{n-1}\\) There are 3 different representations for this polynomial: Coefficient vector: \\(a_0 \\cdot x^0 + a_1 \\cdot x^1 + ... + a_{n-1} \\cdot x^{n-1}\\) Roots: \\(r_0, r_1, ..., r_{n-1}\\) such that \\(A = c \\cdot (x-r_0) \\cdot (x - r_1) \\cdots (x - r_{n-1})\\) Samples of the polynomial: \\((x_k, y_k)\\) for \\(\\; k=0, 1, ...n-1\\) where \\(A(x_k) = y_k \\; \\forall k\\) and \\(x_k\\) 's are distinct We can perform 3 different operation on the polynomials: Evaluate one polynomial Add two polynomials Multiply two polynomials The table for complexity for these operations based on the representation Operation Coefficients Roots Samples Evaluate O(n) O(n) O(n^2) Add O(n) \\(\\infty\\) O(n) Multiply O(n^2) O(n) O(n) Discrete fourier transform is the transform between coefficient and sample representations. Using FFT (fast fourier transform) algorithm we can perform this operation in O(n log n) time. The inverse operation also has same time complexity. The idea is that instead of performing O(n^2) operation, we will use FFT to transform the representation, then do the operation in O(n) time, then transform back with IFFT. This way we can perform all 3 operations in O(n log n) time or less. We can calculate the DFT with DFT Matrix or more efficiently with using FFT","title":"Discrete Fourier Transform"},{"location":"math/discrete_fourier_transform/#links","text":"Divide & Conquer: FFT MIT OpenCourseWare DSP Lecture 10: The Discrete Fourier Transform","title":"Links"},{"location":"math/vandermonde_matrix/","text":"Vandermonde matrix \\[{\\displaystyle V={\\begin{bmatrix}1&x_{0}&x_{0}^{2}&\\dots &x_{0}^{n-1}\\\\1&x_{1}&x_{1}^{2}&\\dots &x_{1}^{n-1}\\\\1&x_{2}&x_{2}^{2}&\\dots &x_{2}^{n-1}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\1&x_{m-1}&x_{m-1}^{2}&\\dots &x_{m-1}^{n-1}\\end{bmatrix}}}\\] Vandermonde matrix maps the vector of coefficients of a polynomial to the vector of the values of the polynomial at the values appearing in the Vandermonde matrix. So coefficients -> samples. The discrete Fourier transform is defined by a specific Vandermonde matrix, the DFT matrix, where the numbers \\(x_i\\) are chosen to be roots of unity. Links: wikipedia","title":"Vandermonde Matrix"},{"location":"math/vandermonde_matrix/#vandermonde-matrix","text":"\\[{\\displaystyle V={\\begin{bmatrix}1&x_{0}&x_{0}^{2}&\\dots &x_{0}^{n-1}\\\\1&x_{1}&x_{1}^{2}&\\dots &x_{1}^{n-1}\\\\1&x_{2}&x_{2}^{2}&\\dots &x_{2}^{n-1}\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\1&x_{m-1}&x_{m-1}^{2}&\\dots &x_{m-1}^{n-1}\\end{bmatrix}}}\\] Vandermonde matrix maps the vector of coefficients of a polynomial to the vector of the values of the polynomial at the values appearing in the Vandermonde matrix. So coefficients -> samples. The discrete Fourier transform is defined by a specific Vandermonde matrix, the DFT matrix, where the numbers \\(x_i\\) are chosen to be roots of unity. Links: wikipedia","title":"Vandermonde matrix"},{"location":"math/abstract_algebra/abstract_algebra/","text":"Abstract Algebra Field Field is a set \\(F\\) together with two binary operations addition ( \\(+\\) ) and multiplication ( \\(\\cdot\\) ) that satisfy the following properties: Associativity of addition and multiplication: \\(a + (b + c) = (a + b) + c\\) , and \\(a \\cdot (b \\cdot c) = (a \\cdot b) \\cdot c\\) . Commutativity of addition and multiplication: \\(a + b = b + a\\) , and \\(a \\cdot b = b \\cdot a\\) Additive and multiplicative identity : there exists different elements \\(0\\) and \\(1\\) such that \\(a + 0 = a\\) and \\(a \\cdot 1 = a\\) Additive inverses : for every \\(a\\) in \\(F\\) there exists an element in \\(F\\) : \\(-a\\) such that \\(a + (-a) = 0\\) . Multiplicative inverses : for every \\(a \\neq 0\\) in \\(F\\) there exists an element in \\(F\\) : \\(a^{-1}\\) such that \\(a \\cdot a^{-1} = 1\\) . Distributivity of multiplication over addition: \\(a \\cdot (b + c) = (a \\cdot b) + (a \\cdot c)\\) . Summarized a field is a commutative ring where \\(0 \\neq 1\\) and all nonzero elements are invertible. Finite field A field with finite number of elements is called finite field (or Galois field). The number of elements is always of form \\(p^k\\) , where \\(p\\) is a prime number, and \\(k\\) is a positive integer. For example there is no finite field with \\(10 = 2 \\cdot 5\\) elements. But there is one with \\(256 = 2 ^ 8\\) elements. Uniqueness of finite fields: all finite fields with the same number of elements are isomorphic. Mutliplicative group In a field, the non-zero elements with multiplication form a group. This is called multiplicative group. Fundamental theorem of finite abelian groups Let \\(G\\) be a finite abelian group. Then \\(G\\) is a direct product of cyclic groups of prime-power order. Example - Number of different abelian groups with 1008 elements? Prime factorization: \\(1008 = 2^4 \\cdot 3^2 \\cdot 7\\) . Looking at the powers we get 4, 2, 1. We get the result by multiplying the different partitions of these numbers. 4 can be partitioned 5 ways: \\(4, 3+1, 2+2, 2+1+1, 1+1+1+1\\) 2 can be partitioned 2 ways: \\(2, 1+1\\) 1 can be partitioned 1 way: \\(1\\) So overall \\(5 \\cdot 2 \\cdot 1 = 10\\) different abelian groups with 1008 elements. Example - Number of different abelian groups with 256 elements? Prime factorization: \\(256 = 2^8\\) . There are 22 partitions of 8, so there are 22 different abelian groups with 256 elements. Links Finite field - wikipedia 301.11D The Fundamental Theorem of Finite Abelian Groups - youtube","title":"General"},{"location":"math/abstract_algebra/abstract_algebra/#abstract-algebra","text":"","title":"Abstract Algebra"},{"location":"math/abstract_algebra/abstract_algebra/#field","text":"Field is a set \\(F\\) together with two binary operations addition ( \\(+\\) ) and multiplication ( \\(\\cdot\\) ) that satisfy the following properties: Associativity of addition and multiplication: \\(a + (b + c) = (a + b) + c\\) , and \\(a \\cdot (b \\cdot c) = (a \\cdot b) \\cdot c\\) . Commutativity of addition and multiplication: \\(a + b = b + a\\) , and \\(a \\cdot b = b \\cdot a\\) Additive and multiplicative identity : there exists different elements \\(0\\) and \\(1\\) such that \\(a + 0 = a\\) and \\(a \\cdot 1 = a\\) Additive inverses : for every \\(a\\) in \\(F\\) there exists an element in \\(F\\) : \\(-a\\) such that \\(a + (-a) = 0\\) . Multiplicative inverses : for every \\(a \\neq 0\\) in \\(F\\) there exists an element in \\(F\\) : \\(a^{-1}\\) such that \\(a \\cdot a^{-1} = 1\\) . Distributivity of multiplication over addition: \\(a \\cdot (b + c) = (a \\cdot b) + (a \\cdot c)\\) . Summarized a field is a commutative ring where \\(0 \\neq 1\\) and all nonzero elements are invertible.","title":"Field"},{"location":"math/abstract_algebra/abstract_algebra/#finite-field","text":"A field with finite number of elements is called finite field (or Galois field). The number of elements is always of form \\(p^k\\) , where \\(p\\) is a prime number, and \\(k\\) is a positive integer. For example there is no finite field with \\(10 = 2 \\cdot 5\\) elements. But there is one with \\(256 = 2 ^ 8\\) elements. Uniqueness of finite fields: all finite fields with the same number of elements are isomorphic.","title":"Finite field"},{"location":"math/abstract_algebra/abstract_algebra/#mutliplicative-group","text":"In a field, the non-zero elements with multiplication form a group. This is called multiplicative group.","title":"Mutliplicative group"},{"location":"math/abstract_algebra/abstract_algebra/#fundamental-theorem-of-finite-abelian-groups","text":"Let \\(G\\) be a finite abelian group. Then \\(G\\) is a direct product of cyclic groups of prime-power order. Example - Number of different abelian groups with 1008 elements? Prime factorization: \\(1008 = 2^4 \\cdot 3^2 \\cdot 7\\) . Looking at the powers we get 4, 2, 1. We get the result by multiplying the different partitions of these numbers. 4 can be partitioned 5 ways: \\(4, 3+1, 2+2, 2+1+1, 1+1+1+1\\) 2 can be partitioned 2 ways: \\(2, 1+1\\) 1 can be partitioned 1 way: \\(1\\) So overall \\(5 \\cdot 2 \\cdot 1 = 10\\) different abelian groups with 1008 elements. Example - Number of different abelian groups with 256 elements? Prime factorization: \\(256 = 2^8\\) . There are 22 partitions of 8, so there are 22 different abelian groups with 256 elements.","title":"Fundamental theorem of finite abelian groups"},{"location":"math/abstract_algebra/abstract_algebra/#links","text":"Finite field - wikipedia 301.11D The Fundamental Theorem of Finite Abelian Groups - youtube","title":"Links"},{"location":"math/abstract_algebra/monoid/","text":"Abstract algebra monoid Magma Magma is a set equipped with a binary operation that is closed: \\[ a,b \\in S \\implies a \\cdot b \\in S. \\] Semigroup Magma that is associative : $$ \\forall a, b. c \\in S \\implies (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c) $$ is called a semigroup. Monoid Semigroup with identity \\(e\\) : $$ \\exists e \\in S \\text{ such that } \\forall a \\in S: e \\cdot a = a = a \\cdot e $$ is called a monoid. Group Monoid where every element has an inverse : $$ \\forall a \\in S \\; \\exists \\; b \\text{ such that } a \\cdot b = e \\text{, where }e\\text{ is the identity element} $$ is called a group. Links image source wikipedia","title":"Monoid"},{"location":"math/abstract_algebra/monoid/#abstract-algebra-monoid","text":"","title":"Abstract algebra monoid"},{"location":"math/abstract_algebra/monoid/#magma","text":"Magma is a set equipped with a binary operation that is closed: \\[ a,b \\in S \\implies a \\cdot b \\in S. \\]","title":"Magma"},{"location":"math/abstract_algebra/monoid/#semigroup","text":"Magma that is associative : $$ \\forall a, b. c \\in S \\implies (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c) $$ is called a semigroup.","title":"Semigroup"},{"location":"math/abstract_algebra/monoid/#monoid","text":"Semigroup with identity \\(e\\) : $$ \\exists e \\in S \\text{ such that } \\forall a \\in S: e \\cdot a = a = a \\cdot e $$ is called a monoid.","title":"Monoid"},{"location":"math/abstract_algebra/monoid/#group","text":"Monoid where every element has an inverse : $$ \\forall a \\in S \\; \\exists \\; b \\text{ such that } a \\cdot b = e \\text{, where }e\\text{ is the identity element} $$ is called a group.","title":"Group"},{"location":"math/abstract_algebra/monoid/#links","text":"image source wikipedia","title":"Links"}]}